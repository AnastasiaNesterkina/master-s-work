#include "task.h"
// allTasks is generated by user
std::queue<ITask*> allTasks;
std::ofstream fTime;
time_t rawtime;
struct tm * timeinfo;

char buffer[80];
double eps = 1e-8;
bool CheckConditions() {
	if (residual > eps) return true;
	else return false;
}
void FindSolution() {	
	MPI_Status st;
	
	std::string nameFile = "src/loading/" + folderName + "loading" + std::to_string(rank) + ".txt";
	std::ofstream fLoading(nameFile);

	for (iteration = 0; iteration < maxiter && CheckConditions(); iteration++) {
		if (rank == 0) printf("%d::  --------------------START ITERATION %d---------------------\n", rank, iteration);
		for (auto &i : newResult) i = 0;
		for (auto &i : oldResult) i = 0;
		auto t_start = std::chrono::high_resolution_clock::now();
		//fprintf(stderr, "\n%d:: cс of tasks = %d\n\n", rank, allTasks.size());
		while (!allTasks.empty()) {
			Task *t = dynamic_cast<Task*>(allTasks.front());
			//if (rank == 1) fprintf(stderr, "%d:: recv borders of task %d.\n", rank, t->blockNumber);
			if (iteration != 0) t->ReceiveFromNeighbors(currentComm);
			queueRecv.push(t);
			allTasks.pop();
		}
		//fprintf(stderr, "\n%d:: c of tasks = %d\n\n", rank, queueRecv.size());
		while (!queueRecv.empty()) {
			Task *t = dynamic_cast<Task*>(queueRecv.front());
			//fprintf(stderr, "%d:: wait borders of task %d.\n", rank, t->blockNumber);
			if (iteration != 0) t->WaitBorders();			
			//fprintf(stderr, "%d:: get borders of task %d.\n", rank, t->blockNumber);
			AddTask(t);
			queueRecv.pop();
		}

		//fprintf(stderr, "\n%d:: count of tasks = %d\n\n", rank, currentTasks.size());
		
		StartWork(false);

		if (changeExist) {
			changeExist = false;
			if (rank == 0) {
				//fprintf(stderr, "%d:: send iteration.\n", rank);
				for (int k = size_old; k < size; k++)
					MPI_Send(&iteration, 1, MPI_INT, k, 10005, currentComm);
			}
		}
		//fprintf(stderr, "%d:: get to generate result of iteration\n", rank);
		GenerateResultOfIteration(currentComm);
		//fprintf(stderr, "%d:: generate result of iteration\n", rank);
		while (!queueRecv.empty()) {
			Task *t = dynamic_cast<Task*>(queueRecv.front());
			t->SendToNeighbors(currentComm);
			queueRecv.pop();
			allTasks.push(t);
		}
		auto t_end = std::chrono::high_resolution_clock::now();
		//printf("%d:: res = %e\n", rank, residual);
		if (rank == 0) {
			printf("%d:: res = %e\n", rank, residual);
			printf("%d:: --------------------FINISH ITERATION %d---------------------\n", rank, iteration);

		}
		if (rank == 0) {
			fTime << "iteration " << iteration << "::  " << std::chrono::duration<double, std::milli>(t_end - t_start).count() << " ms\n";
		}
		fLoading << "iteration " << iteration << "::  " << allTasks.size() << "\ttasks\n";
	}		
	fLoading.close();
	GenerateResult(currentComm);
	CloseLibraryComponents();
}

int main(int argc, char **argv) {
	time(&rawtime);
	timeinfo = localtime(&rawtime);
	strftime(buffer, 80, "%H:%M:%S", timeinfo);
	puts(buffer);
	LibraryInitialize(argc, argv, false);
	if (rank == 0) fTime.open("src/loading/"+ folderName +"time_server.txt");
	if (rank == 0) 	fTime << "servers's processes start in " << buffer << "\n";
	GenerateBasicConcepts();
	GenerateQueueOfTask(allTasks, map);
	std::vector<int> tmp(map.size());
	map.resize(map.size());
	MPI_Allreduce(map.data(), tmp.data(), map.size(), MPI_INT, MPI_SUM, currentComm);
	map = tmp;
	
	CreateLibraryComponents();
	FindSolution();
	MPI_Finalize();
	if (rank == 0) fTime.close();
	return 0;
}
