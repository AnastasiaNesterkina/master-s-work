#include "task.h"
// allTasks is generated by user
std::queue<ITask*> allTasks;
bool client = true;
time_t rawtime;
struct tm * timeinfo;

char buffer[80];
std::ofstream fTime;
double eps = 1e-8;

bool CheckConditions() {
	if (residual > eps) return true;
	else return false;
}
void FindSolution() {
	MPI_Status st;
	
	std::string nameFile = "src/loading/loading" + std::to_string(rank) + ".txt";
	std::ofstream fLoading(nameFile);
	
	StartWork(true);
	MPI_Recv(&iteration, 1, MPI_INT, 0, 10005, reduceComm, &st);
	//fprintf(stderr, "%d:: iteration = %d.\n", rank, iteration);
	iteration++;
	client = false;
	GenerateResultOfIteration(reduceComm); 
	while (!queueRecv.empty()) {
		Task *t = dynamic_cast<Task*>(queueRecv.front());
		t->SendToNeighbors(reduceComm);
		allTasks.push(t);
		queueRecv.pop();
	}
	for (; iteration < maxiter && CheckConditions(); iteration++) {
		//if (oldClientRank == 0) printf("%d::  --------------------START ITERATION %d---------------------\n", rank, iteration);
		for (auto &i : newResult) i = 0;
		for (auto &i : oldResult) i = 0;

		while (!allTasks.empty()) {
			Task *t = dynamic_cast<Task*>(allTasks.front());
			if (iteration != 0) t->ReceiveFromNeighbors(reduceComm);
			queueRecv.push(t);
			allTasks.pop();
		}

		while (!queueRecv.empty()) {
			Task *t = dynamic_cast<Task*>(queueRecv.front());
			if (iteration != 0) t->WaitBorders();
			AddTask(t);
			queueRecv.pop();
		}
		//fprintf(stderr, "%d:: count of tasks = %d\n", rank, currentTasks.size());

		StartWork(false);
				
		GenerateResultOfIteration(reduceComm);

		while (!queueRecv.empty()) {
			Task *t = dynamic_cast<Task*>(queueRecv.front());
			t->SendToNeighbors(reduceComm);
			allTasks.push(t);
			queueRecv.pop();
		}
		fLoading << "iteration " << iteration << "::  " << allTasks.size() << "\ttasks\n";
		//if (oldClientRank == 0) printf("%d:: --------------------FINISH ITERATION %d---------------------\n", rank, iteration);
	}	
	fLoading.close();
	
	GenerateResult(reduceComm);
	CloseLibraryComponents();	
}

int main(int argc, char **argv) {
	LibraryInitialize(argc, argv, true);
	// If work exist
	if (map.size())	{
		GenerateBasicConcepts();
		FindSolution();
	}
	MPI_Finalize();
	return 0;
}
